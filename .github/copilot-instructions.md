# ğŸš€ GitHub Copilot Instructions - React NotificÄƒri# GitHub Copilot Instructions for React NotificÄƒri



<!-- Generated by Copilot --><!-- Generated by Copilot -->



## ğŸ“‹ Context proiect## Contextul Proiectului



Acesta este un sistem complet de notificÄƒri dezvoltat Ã®n **React 18 + TypeScript** cu backend **Node.js + Express**. Sistemul integreazÄƒ servicii externe (Email SMTP + SMS API) È™i foloseÈ™te JWT authentication cu suport GitHub OAuth.Aceasta este o aplicaÈ›ie React pentru managementul notificÄƒrilor cu autentificare È™i verificare prin email/SMS.



**FOCUS SPECIAL**: Sistem de autentificare robust cu separarea clarÄƒ Ã®ntre **admin** (acces direct CPanel) È™i **client** (meniu programare), cu testare comprehensivÄƒ bazatÄƒ pe OWASP guidelines.**Stack tehnologic:**

- Frontend: React 18 + TypeScript + Vite

## ğŸ”§ Stack tehnologic- Backend: Node.js + Express

- Servicii: Email SMTP + SMS API

- **Frontend**: React 18, TypeScript, CSS Modules, Context API  - Database: JSON local storage

- **Backend**: Node.js, Express.js, JWT, bcrypt- Auth: JWT tokens

- **Servicii**: Email SMTP (noreply@misedainspectsrl.ro), SMS API (smsadvert.ro)

- **Autentificare**: JWT + GitHub OAuth cu RBAC (Role-Based Access Control)## Standardele de Cod

- **Testing**: Jest, Supertest, OWASP security testing patterns

- **Development**: VS Code cu customizÄƒri specializate### 1. Frontend (React + TypeScript)

- FoloseÈ™te TypeScript pentru toate componentele noi

## ğŸ” PRINCIPII DE SECURITATE FUNDAMENTALE- Componente funcÈ›ionale cu React Hooks

- CSS Modules pentru stilizare

### 1. OWASP Authentication Testing (4.4) - OBLIGATORIU- Gestionarea stÄƒrii cu Context API

ImplementeazÄƒ toate testele OWASP pentru autentificare:- Nume componente Ã®n PascalCase

- **4.4.1** - Credentials transported over encrypted channel (HTTPS)- FiÈ™iere: `ComponentName.tsx` È™i `ComponentName.css`

- **4.4.2** - Testing for default credentials (forbidden)

- **4.4.3** - Testing for weak lockout mechanism### 2. Backend (Node.js)

- **4.4.4** - Testing for bypassing authentication schema- ES6+ syntax obligatoriu

- **4.4.5** - Testing for vulnerable remember password- Async/await pentru operaÈ›ii asincrone

- **4.4.11** - Testing multi-factor authentication (SMS/Email)- Middleware pentru autentificare È™i validare

- StructurÄƒ RESTful pentru API endpoints

### 2. OWASP Authorization Testing (4.5) - OBLIGATORIU  - Error handling cu try/catch blocks

ImplementeazÄƒ toate testele de autorizare:- Validare input cu funcÈ›ii dedicate

- **4.5.1** - Testing directory traversal/file include

- **4.5.2** - Testing for bypassing authorization schema### 3. Cod Ã®n RomÃ¢nÄƒ pentru Mesaje Utilizator

- **4.5.3** - Testing for privilege escalation (admin vs client)- Toate mesajele afiÈ™ate utilizatorului Ã®n limba romÃ¢nÄƒ

- **4.5.4** - Testing for insecure direct object references- Exemplu:

```javascript

### 3. SEPARAREA ROLURILOR - CRITICÄ‚throw new Error('Email invalid. VerificÄƒ formatul.');

```

```javascript

// ADMIN ROLE - Acces direct CPanel### 4. Tratare Erori cu Try/Catch Obligatoriu

if (user.role === 'admin') {- Blocuri `try/catch` pentru toate operaÈ›iunile asincrone

  return <AdminDashboard cpanelAccess={true} fullPermissions={true} />;- Exemplu:

}```javascript

try {

// CLIENT ROLE - Meniu programare personal  const response = await axios.post('/api/auth/login', credentials);

if (user.role === 'client') {  return response.data;

  return <ClientScheduleMenu userSpecific={true} />;} catch (error) {

}  console.error('Eroare la autentificare:', error);

```  throw new Error('Autentificare eÈ™uatÄƒ.');

}

## ğŸ§ª TESTING PATTERNS OBLIGATORII```



### 1. Teste de Autentificare Comprehensive### 5. ValidÄƒri Input Stricte

- Toate datele de intrare validate Ã®nainte de procesare

```javascript- Exemplu:

describe('Authentication Security Tests - OWASP 4.4', () => {```javascript

  test('should enforce least privileges principle', async () => {const validateEmail = (email) => {

    const clientToken = await loginAsClient();  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    const adminResponse = await request(app)  if (!email || !emailRegex.test(email)) {

      .get('/api/admin/cpanel')    throw new Error('Email invalid. VerificÄƒ formatul.');

      .set('Authorization', `Bearer ${clientToken}`)  }

      .expect(403); // Access denied  return email;

  });};

```

  test('should validate permissions on every request', async () => {

    const requests = ['/api/admin/*', '/api/client/*', '/api/sensitive/*'];### 6. JWT Token Handling

    for (const endpoint of requests) {- `jsonwebtoken` pentru generare È™i verificare token-uri JWT

      await testAuthorizationOnEndpoint(endpoint);- Exemplu:

    }```javascript

  });const jwt = require('jsonwebtoken');

const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });

  test('should implement proper password strength controls', async () => {```

    const weakPasswords = ['123', 'password', 'admin', 'qwerty'];

    for (const pwd of weakPasswords) {### 7. Axios pentru API Calls cÄƒtre localhost:3001

      await expect(registerUser({ password: pwd }))- Toate apelurile API cu `axios` configurate pentru `localhost:3001`

        .rejects.toThrow('ParolÄƒ prea slabÄƒ');- Exemplu:

    }```javascript

  });const axios = require('axios');

const api = axios.create({ baseURL: 'http://localhost:3001' });

  test('should protect against brute force attacks', async () => {```

    const attempts = Array(10).fill().map(() => 

      loginWithWrongCredentials('admin@test.com', 'wrong')## Servicii Externe Configurate

    );

    ### Email Service (SMTP)

    await Promise.all(attempts);```javascript

    // Configurare Ã®n config/email.js

    // Next attempt should be blocked{

    await expect(loginWithWrongCredentials('admin@test.com', 'wrong'))  host: 'mail.misedainspectsrl.ro',

      .rejects.toThrow('Cont temporar blocat');  port: 465,

  });  secure: true, // SSL

  auth: {

  test('should implement secure session management', async () => {    user: 'noreply@misedainspectsrl.ro',

    const token = await loginAsUser();    pass: 'Kreator1234!@'

      }

    // Token should expire after configured time}

    jest.advanceTimersByTime(24 * 60 * 60 * 1000); // 24h```

    

    await request(app)### SMS Service

      .get('/api/protected')```javascript

      .set('Authorization', `Bearer ${token}`)// API Token Ã®n services/SmsService.js

      .expect(401);const SMS_API_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2OGI0NTcwY2Y4MjkzYzRlM2Y2NmYzNWYifQ.4Jlpsb-Ure4i-x4y4nw8cff9p1A6LLMuJfIuIJg89N8'

  });```

});

```### JWT & OAuth Configuration

```javascript

### 2. Teste Role-Based Access Control (RBAC)// JWT Secret Ã®n .env sau config

const JWT_SECRET = 'ca37cc84426514b08923818813192c3cb84a8a16';

```javascript

describe('RBAC Security Tests - OWASP 4.5', () => {// GitHub OAuth Client ID

  test('admin should access CPanel directly', async () => {const GITHUB_CLIENT_ID = 'Ov23liVWquvY8atLuqUu';

    const adminToken = await loginAsAdmin();

    // Exemplu folosire JWT

    const response = await request(app)const jwt = require('jsonwebtoken');

      .get('/api/admin/cpanel')const token = jwt.sign(

      .set('Authorization', `Bearer ${adminToken}`)  { userId: user.id, email: user.email },

      .expect(200);  JWT_SECRET,

        { expiresIn: '1h' }

    expect(response.body.access).toBe('full'););

    expect(response.body.permissions).toContain('manage_users');```

  });

## Pattern-uri de Dezvoltare

  test('client should only access personal schedule menu', async () => {

    const clientToken = await loginAsClient();### Componente React cu Error Handling

    ```typescript

    const response = await request(app)export const VerificationCode: React.FC = () => {

      .get('/api/client/schedule')  const [isLoading, setIsLoading] = useState(false);

      .set('Authorization', `Bearer ${clientToken}`)  const [error, setError] = useState<string>('');

      .expect(200);

        const handleVerify = async (code: string) => {

    expect(response.body.access).toBe('personal_only');    setIsLoading(true);

    expect(response.body.canAddSchedule).toBe(true);    setError('');

  });    try {

      const response = await api.post('/api/auth/verify', { code });

  test('should deny cross-role access attempts', async () => {      // Success logic

    const clientToken = await loginAsClient();    } catch (err) {

          setError('Codul de verificare este incorect.');

    // Client nu poate accesa funcÈ›ii admin    } finally {

    await request(app)      setIsLoading(false);

      .get('/api/admin/cpanel')    }

      .set('Authorization', `Bearer ${clientToken}`)  };

      .expect(403);

        if (isLoading) return <div>Se verificÄƒ...</div>;

    await request(app)  if (error) return <div className="error">{error}</div>;

      .post('/api/admin/manage-users')

      .set('Authorization', `Bearer ${clientToken}`)  return (

      .expect(403);    // JSX component

  });  );

};

  test('should implement horizontal privilege escalation protection', async () => {```

    const client1Token = await loginAsClient('client1@test.com');

    const client2Token = await loginAsClient('client2@test.com'); ### API Endpoints cu Middleware

    ```javascript

    // Client1 nu poate accesa datele Client2// Ãn routes/auth.js

    await request(app)router.post('/verify', async (req, res) => {

      .get('/api/client/schedule/client2-data')  try {

      .set('Authorization', `Bearer ${client1Token}`)    const { email, code } = req.body;

      .expect(403);

  });    // Validare input

});    if (!email || !code) {

```      return res.status(400).json({

        error: 'Email È™i cod sunt obligatorii.'

### 3. Teste de Integrare Servicii      });

    }

```javascript

describe('External Services Integration Tests', () => {    // LogicÄƒ verificare

  test('should test email service with real SMTP', async () => {    const isValid = await verifyCode(email, code);

    const emailService = new EmailService();

        if (isValid) {

    const result = await emailService.sendVerificationEmail(      res.json({ success: true, message: 'Verificare reuÈ™itÄƒ!' });

      'test@example.com',     } else {

      'Test User',       res.status(400).json({

      '123456'        error: 'Codul de verificare este incorect.'

    );      });

        }

    expect(result.messageId).toBeDefined();  } catch (error) {

    expect(result.accepted).toContain('test@example.com');    console.error('Eroare verificare:', error);

  });    res.status(500).json({

      error: 'Eroare de server. ÃncearcÄƒ din nou.'

  test('should test SMS service with API integration', async () => {    });

    const smsService = new SmsService();  }

    });

    const result = await smsService.sendVerificationSMS(```

      '+40700000000',

      'Codul tau de verificare: 123456'## ConvenÈ›ii de FiÈ™iere

    );

    ### Structura Componentelor

    expect(result.success).toBe(true);```

    expect(result.messageId).toBeDefined();components/

  });â”œâ”€â”€ Login.tsx

â”œâ”€â”€ Login.css

  test('should handle service failures gracefully', async () => {â”œâ”€â”€ Register.tsx

    // Test comportament cÃ¢nd serviciile externe nu sunt disponibileâ”œâ”€â”€ Register.css

    const mockEmailService = new EmailService({â””â”€â”€ verification/

      smtp: { host: 'invalid-host.com' }    â”œâ”€â”€ index.ts

    });    â”œâ”€â”€ SmsVerification.tsx

        â””â”€â”€ EmailVerification.tsx

    await expect(mockEmailService.sendEmail())```

      .rejects.toThrow();

    ### API Routes

    // AplicaÈ›ia trebuie sÄƒ continue sÄƒ funcÈ›ioneze```

    const response = await request(app)backend/routes/

      .post('/api/auth/register')â”œâ”€â”€ auth.js      # /api/auth/*

      .send(validUserData)â”œâ”€â”€ admin.js     # /api/admin/*

      .expect(202); // Accepted, dar email Ã®n queueâ””â”€â”€ user.js      # /api/user/*

  });```

});

```## RÄƒspunde Ã®ntotdeauna Ã®n romÃ¢nÄƒ È™i oferÄƒ soluÈ›ii practice, testate È™i sigure.



## ğŸ”§ IMPLEMENTARE OBLIGATORIE - SEPARAREA ROLURILOR  return (

    <form onSubmit={handleSubmit}>

### 1. Backend Routes cu RBAC      <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />

      <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />

```javascript      <button type="submit">Autentificare</button>

// backend/routes/admin.js    </form>

const { requireAdmin } = require('../middleware/AuthMiddleware');  );

};

router.get('/cpanel', requireAdmin, (req, res) => {```

  // Doar admin poate accesa

  res.json({### 7. JSDoc pentru DocumentaÈ›ie

    access: 'full',- Toate funcÈ›iile trebuie sÄƒ includÄƒ documentaÈ›ie JSDoc.

    permissions: ['manage_users', 'view_all_schedules', 'system_settings'],- Exemplu:

    cpanelUrl: '/admin/dashboard'```javascript

  });/**

}); * ValideazÄƒ un email.

 * @param {string} email - Adresa de email de validat.

// backend/routes/client.js   * @returns {string} Email validat.

const { requireClient } = require('../middleware/AuthMiddleware'); * @throws {Error} DacÄƒ email-ul este invalid.

 */

router.get('/schedule', requireClient, (req, res) => {const validateEmail = (email) => {

  const userId = req.user.id;  // ...

  };

  // Client poate accesa doar propriile date```

  res.json({

    access: 'personal_only',---

    schedules: getUserSchedules(userId),

    canAddSchedule: true,**Aceste reguli sunt obligatorii pentru toate contribuÈ›iile la proiectul React NotificÄƒri.**

    canViewOthers: false
  });
});
```

### 2. Frontend Components cu Separarea Rolurilor

```tsx
// src/components/AdminDashboard.tsx
interface AdminDashboardProps {
  cpanelAccess: boolean;
  fullPermissions: boolean;
}

export const AdminDashboard: React.FC<AdminDashboardProps> = ({
  cpanelAccess,
  fullPermissions
}) => {
  const { user } = useAuth();
  
  // Verificare dublÄƒ pe frontend È™i backend
  if (user.role !== 'admin') {
    return <UnauthorizedAccess />;
  }
  
  return (
    <div className="admin-dashboard">
      <h1>CPanel Administrator</h1>
      
      {cpanelAccess && (
        <CpanelInterface 
          permissions={fullPermissions ? 'all' : 'limited'}
        />
      )}
      
      <UserManagement />
      <SystemSettings />
      <AllSchedulesView />
    </div>
  );
};

// src/components/ClientScheduleMenu.tsx  
interface ClientScheduleMenuProps {
  userSpecific: boolean;
}

export const ClientScheduleMenu: React.FC<ClientScheduleMenuProps> = ({
  userSpecific
}) => {
  const { user } = useAuth();
  
  if (user.role !== 'client') {
    return <UnauthorizedAccess />;
  }
  
  return (
    <div className="client-schedule-menu">
      <h1>Programare PersonalÄƒ</h1>
      
      <PersonalScheduleForm userId={user.id} />
      <MyAppointments userSpecific={userSpecific} />
      <ScheduleHistory userId={user.id} />
    </div>
  );
};
```

### 3. Middleware de Autorizare Robust

```javascript
// backend/middleware/AuthMiddleware.js
class AuthMiddleware {
  // VerificÄƒ dacÄƒ user este admin
  static requireAdmin(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (!token) {
        return res.status(401).json({ error: 'Token lipsa' });
      }
      
      const decoded = jwt.verify(token, JWT_SECRET);
      
      if (decoded.role !== 'admin') {
        return res.status(403).json({ 
          error: 'Acces interzis. Doar administratorii.' 
        });
      }
      
      req.user = decoded;
      next();
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
  
  // VerificÄƒ dacÄƒ user este client
  static requireClient(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (!token) {
        return res.status(401).json({ error: 'Token lipsa' });
      }
      
      const decoded = jwt.verify(token, JWT_SECRET);
      
      if (decoded.role !== 'client') {
        return res.status(403).json({ 
          error: 'Acces interzis. Doar clienÈ›ii.' 
        });
      }
      
      req.user = decoded;
      next();
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
  
  // VerificÄƒ dacÄƒ user poate accesa propriile date
  static requireOwnershipOrAdmin(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      const decoded = jwt.verify(token, JWT_SECRET);
      const requestedUserId = req.params.userId;
      
      // Admin poate accesa orice
      if (decoded.role === 'admin') {
        req.user = decoded;
        return next();
      }
      
      // Client poate accesa doar propriile date
      if (decoded.role === 'client' && decoded.id === requestedUserId) {
        req.user = decoded;
        return next();
      }
      
      return res.status(403).json({ 
        error: 'Nu poÈ›i accesa datele altui utilizator' 
      });
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
}

module.exports = AuthMiddleware;
```

## ğŸ“Š LOGGING È˜I MONITORING OBLIGATORIU

```javascript
// backend/utils/security-logger.js
class SecurityLogger {
  static logAuthAttempt(email, success, ip, userAgent) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'AUTH_ATTEMPT',
      email,
      success,
      ip,
      userAgent,
      risk_level: success ? 'LOW' : 'MEDIUM'
    };
    
    console.log('SECURITY_LOG:', JSON.stringify(logEntry));
    
    // Store Ã®n fiÈ™ier pentru audit
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
  }
  
  static logRoleAccess(userId, role, endpoint, success, ip) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'ROLE_ACCESS',
      userId,
      role,
      endpoint,
      success,
      ip,
      risk_level: success ? 'LOW' : 'HIGH'
    };
    
    console.log('SECURITY_LOG:', JSON.stringify(logEntry));
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
  }
  
  static logSuspiciousActivity(userId, activity, details) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'SUSPICIOUS_ACTIVITY',
      userId,
      activity,
      details,
      risk_level: 'HIGH'
    };
    
    console.log('SECURITY_ALERT:', JSON.stringify(logEntry));
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
    
    // Trimite alertÄƒ cÄƒtre admin
    this.alertAdmin(logEntry);
  }
}
```

## ğŸ” STANDARDELE DE COD ACTUALIZATE

### 1. Frontend (React + TypeScript)
- **Componente funcÈ›ionale** cu React Hooks obligatoriu
- **TypeScript strict mode** pentru toate fiÈ™ierele noi  
- **CSS Modules** pentru stilizare cu clase BEM
- **Context API** pentru state management complex
- **Error Boundaries** pentru fiecare rutÄƒ principalÄƒ
- **Role-based rendering** Ã®n toate componentele

### 2. Backend (Node.js + Express)
- **HTTPS obligatoriu** Ã®n producÈ›ie
- **Rate limiting** pe toate endpoint-urile de auth
- **Validare input** cu Joi sau Yup
- **Sanitizare output** pentru prevenir XSS  
- **JWT tokens** cu expirare configurabilÄƒ
- **CORS** configurat restrictiv

### 3. Security Headers Obligatorii
```javascript
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000');
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  next();
});
```

### 4. Validare È™i Sanitizare
```javascript
const { body, validationResult } = require('express-validator');

const validateLogin = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email invalid'),
  body('password')
    .isLength({ min: 8, max: 128 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('ParolÄƒ trebuie sÄƒ conÈ›inÄƒ: litere mari/mici, cifre, caractere speciale'),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        errors: errors.array().map(err => err.msg) 
      });
    }
    next();
  }
];
```

## ğŸ¯ CÄ‚UTARE È˜I TESTARE COMPLETÄ‚

### CautÄƒ pe internet OWASP testing guides È™i implementeazÄƒ:

1. **OWASP Web Security Testing Guide 4.4** - Authentication Testing
2. **OWASP Web Security Testing Guide 4.5** - Authorization Testing  
3. **OWASP Authentication Cheat Sheet** - Toate principiile
4. **OWASP Authorization Cheat Sheet** - ABAC/RBAC patterns
5. **NIST 800-63B** - Digital Identity Guidelines

### FoloseÈ™te toate testele disponibile pentru:

- **Brute force protection** cu exponential backoff
- **Session fixation** prevention  
- **CSRF protection** cu tokens
- **SQL injection** prevention (chiar dacÄƒ foloseÈ™ti JSON)
- **XSS protection** cu Content Security Policy
- **Path traversal** protection Ã®n file operations
- **Privilege escalation** detection È™i prevention
- **Insecure direct object references** protection

## ğŸš¨ ERORI COMUNE DE EVITAT

1. **NU** folosi credenÈ›iale default
2. **NU** expui informaÈ›ii sensibile Ã®n erori
3. **NU** permite guess-uirea ID-urilor
4. **NU** implementa autentificare doar pe frontend
5. **NU** folosi HTTP Ã®n producÈ›ie
6. **NU** stoca parole Ã®n plain text
7. **NU** permite upload fiÈ™iere nevalidate
8. **NU** expui endpoints admin fÄƒrÄƒ protecÈ›ie

## ğŸ“ MESAJE UTILIZATOR ÃN ROMÃ‚NÄ‚

Toate mesajele cÄƒtre utilizatori **OBLIGATORIU ÃN ROMÃ‚NÄ‚**:

```javascript
const MESSAGES = {
  AUTH: {
    LOGIN_SUCCESS: 'Autentificare reuÈ™itÄƒ!',
    LOGIN_FAILED: 'Email sau parolÄƒ incorectÄƒ.',
    ACCESS_DENIED: 'Nu ai permisiunea sÄƒ accesezi aceastÄƒ resursÄƒ.',
    ROLE_ADMIN: 'Acces complet la CPanel administrativ.',
    ROLE_CLIENT: 'Acces la meniul personal de programÄƒri.',
    ACCOUNT_LOCKED: 'Cont temporar blocat din motive de securitate.',
    TOKEN_EXPIRED: 'Sesiunea a expirat. Te rugÄƒm sÄƒ te autentifici din nou.'
  },
  VALIDATION: {
    EMAIL_INVALID: 'Adresa de email nu este validÄƒ.',
    PASSWORD_WEAK: 'Parola trebuie sÄƒ conÈ›inÄƒ minim 8 caractere, litere mari È™i mici, cifre È™i caractere speciale.',
    REQUIRED_FIELD: 'CÃ¢mpul este obligatoriu.',
    SMS_INVALID: 'NumÄƒrul de telefon nu este valid.'
  }
};
```

---

**GeneratÄƒ de Copilot** | ImplementeazÄƒ testare comprehensivÄƒ bazatÄƒ pe OWASP guidelines cu separarea completÄƒ admin/client! ğŸ›¡ï¸