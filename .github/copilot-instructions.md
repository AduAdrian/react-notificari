# 🚀 GitHub Copilot Instructions - React Notificări# GitHub Copilot Instructions for React Notificări



<!-- Generated by Copilot --><!-- Generated by Copilot -->



## 📋 Context proiect## Contextul Proiectului



Acesta este un sistem complet de notificări dezvoltat în **React 18 + TypeScript** cu backend **Node.js + Express**. Sistemul integrează servicii externe (Email SMTP + SMS API) și folosește JWT authentication cu suport GitHub OAuth.Aceasta este o aplicație React pentru managementul notificărilor cu autentificare și verificare prin email/SMS.



**FOCUS SPECIAL**: Sistem de autentificare robust cu separarea clară între **admin** (acces direct CPanel) și **client** (meniu programare), cu testare comprehensivă bazată pe OWASP guidelines.**Stack tehnologic:**

- Frontend: React 18 + TypeScript + Vite

## 🔧 Stack tehnologic- Backend: Node.js + Express

- Servicii: Email SMTP + SMS API

- **Frontend**: React 18, TypeScript, CSS Modules, Context API  - Database: JSON local storage

- **Backend**: Node.js, Express.js, JWT, bcrypt- Auth: JWT tokens

- **Servicii**: Email SMTP (noreply@misedainspectsrl.ro), SMS API (smsadvert.ro)

- **Autentificare**: JWT + GitHub OAuth cu RBAC (Role-Based Access Control)## Standardele de Cod

- **Testing**: Jest, Supertest, OWASP security testing patterns

- **Development**: VS Code cu customizări specializate### 1. Frontend (React + TypeScript)

- Folosește TypeScript pentru toate componentele noi

## 🔐 PRINCIPII DE SECURITATE FUNDAMENTALE- Componente funcționale cu React Hooks

- CSS Modules pentru stilizare

### 1. OWASP Authentication Testing (4.4) - OBLIGATORIU- Gestionarea stării cu Context API

Implementează toate testele OWASP pentru autentificare:- Nume componente în PascalCase

- **4.4.1** - Credentials transported over encrypted channel (HTTPS)- Fișiere: `ComponentName.tsx` și `ComponentName.css`

- **4.4.2** - Testing for default credentials (forbidden)

- **4.4.3** - Testing for weak lockout mechanism### 2. Backend (Node.js)

- **4.4.4** - Testing for bypassing authentication schema- ES6+ syntax obligatoriu

- **4.4.5** - Testing for vulnerable remember password- Async/await pentru operații asincrone

- **4.4.11** - Testing multi-factor authentication (SMS/Email)- Middleware pentru autentificare și validare

- Structură RESTful pentru API endpoints

### 2. OWASP Authorization Testing (4.5) - OBLIGATORIU  - Error handling cu try/catch blocks

Implementează toate testele de autorizare:- Validare input cu funcții dedicate

- **4.5.1** - Testing directory traversal/file include

- **4.5.2** - Testing for bypassing authorization schema### 3. Cod în Română pentru Mesaje Utilizator

- **4.5.3** - Testing for privilege escalation (admin vs client)- Toate mesajele afișate utilizatorului în limba română

- **4.5.4** - Testing for insecure direct object references- Exemplu:

```javascript

### 3. SEPARAREA ROLURILOR - CRITICĂthrow new Error('Email invalid. Verifică formatul.');

```

```javascript

// ADMIN ROLE - Acces direct CPanel### 4. Tratare Erori cu Try/Catch Obligatoriu

if (user.role === 'admin') {- Blocuri `try/catch` pentru toate operațiunile asincrone

  return <AdminDashboard cpanelAccess={true} fullPermissions={true} />;- Exemplu:

}```javascript

try {

// CLIENT ROLE - Meniu programare personal  const response = await axios.post('/api/auth/login', credentials);

if (user.role === 'client') {  return response.data;

  return <ClientScheduleMenu userSpecific={true} />;} catch (error) {

}  console.error('Eroare la autentificare:', error);

```  throw new Error('Autentificare eșuată.');

}

## 🧪 TESTING PATTERNS OBLIGATORII```



### 1. Teste de Autentificare Comprehensive### 5. Validări Input Stricte

- Toate datele de intrare validate înainte de procesare

```javascript- Exemplu:

describe('Authentication Security Tests - OWASP 4.4', () => {```javascript

  test('should enforce least privileges principle', async () => {const validateEmail = (email) => {

    const clientToken = await loginAsClient();  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    const adminResponse = await request(app)  if (!email || !emailRegex.test(email)) {

      .get('/api/admin/cpanel')    throw new Error('Email invalid. Verifică formatul.');

      .set('Authorization', `Bearer ${clientToken}`)  }

      .expect(403); // Access denied  return email;

  });};

```

  test('should validate permissions on every request', async () => {

    const requests = ['/api/admin/*', '/api/client/*', '/api/sensitive/*'];### 6. JWT Token Handling

    for (const endpoint of requests) {- `jsonwebtoken` pentru generare și verificare token-uri JWT

      await testAuthorizationOnEndpoint(endpoint);- Exemplu:

    }```javascript

  });const jwt = require('jsonwebtoken');

const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });

  test('should implement proper password strength controls', async () => {```

    const weakPasswords = ['123', 'password', 'admin', 'qwerty'];

    for (const pwd of weakPasswords) {### 7. Axios pentru API Calls către localhost:3001

      await expect(registerUser({ password: pwd }))- Toate apelurile API cu `axios` configurate pentru `localhost:3001`

        .rejects.toThrow('Parolă prea slabă');- Exemplu:

    }```javascript

  });const axios = require('axios');

const api = axios.create({ baseURL: 'http://localhost:3001' });

  test('should protect against brute force attacks', async () => {```

    const attempts = Array(10).fill().map(() => 

      loginWithWrongCredentials('admin@test.com', 'wrong')## Servicii Externe Configurate

    );

    ### Email Service (SMTP)

    await Promise.all(attempts);```javascript

    // Configurare în config/email.js

    // Next attempt should be blocked{

    await expect(loginWithWrongCredentials('admin@test.com', 'wrong'))  host: 'mail.misedainspectsrl.ro',

      .rejects.toThrow('Cont temporar blocat');  port: 465,

  });  secure: true, // SSL

  auth: {

  test('should implement secure session management', async () => {    user: 'noreply@misedainspectsrl.ro',

    const token = await loginAsUser();    pass: 'Kreator1234!@'

      }

    // Token should expire after configured time}

    jest.advanceTimersByTime(24 * 60 * 60 * 1000); // 24h```

    

    await request(app)### SMS Service

      .get('/api/protected')```javascript

      .set('Authorization', `Bearer ${token}`)// API Token în services/SmsService.js

      .expect(401);const SMS_API_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2OGI0NTcwY2Y4MjkzYzRlM2Y2NmYzNWYifQ.4Jlpsb-Ure4i-x4y4nw8cff9p1A6LLMuJfIuIJg89N8'

  });```

});

```### JWT & OAuth Configuration

```javascript

### 2. Teste Role-Based Access Control (RBAC)// JWT Secret în .env sau config

const JWT_SECRET = 'ca37cc84426514b08923818813192c3cb84a8a16';

```javascript

describe('RBAC Security Tests - OWASP 4.5', () => {// GitHub OAuth Client ID

  test('admin should access CPanel directly', async () => {const GITHUB_CLIENT_ID = 'Ov23liVWquvY8atLuqUu';

    const adminToken = await loginAsAdmin();

    // Exemplu folosire JWT

    const response = await request(app)const jwt = require('jsonwebtoken');

      .get('/api/admin/cpanel')const token = jwt.sign(

      .set('Authorization', `Bearer ${adminToken}`)  { userId: user.id, email: user.email },

      .expect(200);  JWT_SECRET,

        { expiresIn: '1h' }

    expect(response.body.access).toBe('full'););

    expect(response.body.permissions).toContain('manage_users');```

  });

## Pattern-uri de Dezvoltare

  test('client should only access personal schedule menu', async () => {

    const clientToken = await loginAsClient();### Componente React cu Error Handling

    ```typescript

    const response = await request(app)export const VerificationCode: React.FC = () => {

      .get('/api/client/schedule')  const [isLoading, setIsLoading] = useState(false);

      .set('Authorization', `Bearer ${clientToken}`)  const [error, setError] = useState<string>('');

      .expect(200);

        const handleVerify = async (code: string) => {

    expect(response.body.access).toBe('personal_only');    setIsLoading(true);

    expect(response.body.canAddSchedule).toBe(true);    setError('');

  });    try {

      const response = await api.post('/api/auth/verify', { code });

  test('should deny cross-role access attempts', async () => {      // Success logic

    const clientToken = await loginAsClient();    } catch (err) {

          setError('Codul de verificare este incorect.');

    // Client nu poate accesa funcții admin    } finally {

    await request(app)      setIsLoading(false);

      .get('/api/admin/cpanel')    }

      .set('Authorization', `Bearer ${clientToken}`)  };

      .expect(403);

        if (isLoading) return <div>Se verifică...</div>;

    await request(app)  if (error) return <div className="error">{error}</div>;

      .post('/api/admin/manage-users')

      .set('Authorization', `Bearer ${clientToken}`)  return (

      .expect(403);    // JSX component

  });  );

};

  test('should implement horizontal privilege escalation protection', async () => {```

    const client1Token = await loginAsClient('client1@test.com');

    const client2Token = await loginAsClient('client2@test.com'); ### API Endpoints cu Middleware

    ```javascript

    // Client1 nu poate accesa datele Client2// În routes/auth.js

    await request(app)router.post('/verify', async (req, res) => {

      .get('/api/client/schedule/client2-data')  try {

      .set('Authorization', `Bearer ${client1Token}`)    const { email, code } = req.body;

      .expect(403);

  });    // Validare input

});    if (!email || !code) {

```      return res.status(400).json({

        error: 'Email și cod sunt obligatorii.'

### 3. Teste de Integrare Servicii      });

    }

```javascript

describe('External Services Integration Tests', () => {    // Logică verificare

  test('should test email service with real SMTP', async () => {    const isValid = await verifyCode(email, code);

    const emailService = new EmailService();

        if (isValid) {

    const result = await emailService.sendVerificationEmail(      res.json({ success: true, message: 'Verificare reușită!' });

      'test@example.com',     } else {

      'Test User',       res.status(400).json({

      '123456'        error: 'Codul de verificare este incorect.'

    );      });

        }

    expect(result.messageId).toBeDefined();  } catch (error) {

    expect(result.accepted).toContain('test@example.com');    console.error('Eroare verificare:', error);

  });    res.status(500).json({

      error: 'Eroare de server. Încearcă din nou.'

  test('should test SMS service with API integration', async () => {    });

    const smsService = new SmsService();  }

    });

    const result = await smsService.sendVerificationSMS(```

      '+40700000000',

      'Codul tau de verificare: 123456'## Convenții de Fișiere

    );

    ### Structura Componentelor

    expect(result.success).toBe(true);```

    expect(result.messageId).toBeDefined();components/

  });├── Login.tsx

├── Login.css

  test('should handle service failures gracefully', async () => {├── Register.tsx

    // Test comportament când serviciile externe nu sunt disponibile├── Register.css

    const mockEmailService = new EmailService({└── verification/

      smtp: { host: 'invalid-host.com' }    ├── index.ts

    });    ├── SmsVerification.tsx

        └── EmailVerification.tsx

    await expect(mockEmailService.sendEmail())```

      .rejects.toThrow();

    ### API Routes

    // Aplicația trebuie să continue să funcționeze```

    const response = await request(app)backend/routes/

      .post('/api/auth/register')├── auth.js      # /api/auth/*

      .send(validUserData)├── admin.js     # /api/admin/*

      .expect(202); // Accepted, dar email în queue└── user.js      # /api/user/*

  });```

});

```## Răspunde întotdeauna în română și oferă soluții practice, testate și sigure.



## 🔧 IMPLEMENTARE OBLIGATORIE - SEPARAREA ROLURILOR  return (

    <form onSubmit={handleSubmit}>

### 1. Backend Routes cu RBAC      <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />

      <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />

```javascript      <button type="submit">Autentificare</button>

// backend/routes/admin.js    </form>

const { requireAdmin } = require('../middleware/AuthMiddleware');  );

};

router.get('/cpanel', requireAdmin, (req, res) => {```

  // Doar admin poate accesa

  res.json({### 7. JSDoc pentru Documentație

    access: 'full',- Toate funcțiile trebuie să includă documentație JSDoc.

    permissions: ['manage_users', 'view_all_schedules', 'system_settings'],- Exemplu:

    cpanelUrl: '/admin/dashboard'```javascript

  });/**

}); * Validează un email.

 * @param {string} email - Adresa de email de validat.

// backend/routes/client.js   * @returns {string} Email validat.

const { requireClient } = require('../middleware/AuthMiddleware'); * @throws {Error} Dacă email-ul este invalid.

 */

router.get('/schedule', requireClient, (req, res) => {const validateEmail = (email) => {

  const userId = req.user.id;  // ...

  };

  // Client poate accesa doar propriile date```

  res.json({

    access: 'personal_only',---

    schedules: getUserSchedules(userId),

    canAddSchedule: true,**Aceste reguli sunt obligatorii pentru toate contribuțiile la proiectul React Notificări.**

    canViewOthers: false
  });
});
```

### 2. Frontend Components cu Separarea Rolurilor

```tsx
// src/components/AdminDashboard.tsx
interface AdminDashboardProps {
  cpanelAccess: boolean;
  fullPermissions: boolean;
}

export const AdminDashboard: React.FC<AdminDashboardProps> = ({
  cpanelAccess,
  fullPermissions
}) => {
  const { user } = useAuth();
  
  // Verificare dublă pe frontend și backend
  if (user.role !== 'admin') {
    return <UnauthorizedAccess />;
  }
  
  return (
    <div className="admin-dashboard">
      <h1>CPanel Administrator</h1>
      
      {cpanelAccess && (
        <CpanelInterface 
          permissions={fullPermissions ? 'all' : 'limited'}
        />
      )}
      
      <UserManagement />
      <SystemSettings />
      <AllSchedulesView />
    </div>
  );
};

// src/components/ClientScheduleMenu.tsx  
interface ClientScheduleMenuProps {
  userSpecific: boolean;
}

export const ClientScheduleMenu: React.FC<ClientScheduleMenuProps> = ({
  userSpecific
}) => {
  const { user } = useAuth();
  
  if (user.role !== 'client') {
    return <UnauthorizedAccess />;
  }
  
  return (
    <div className="client-schedule-menu">
      <h1>Programare Personală</h1>
      
      <PersonalScheduleForm userId={user.id} />
      <MyAppointments userSpecific={userSpecific} />
      <ScheduleHistory userId={user.id} />
    </div>
  );
};
```

### 3. Middleware de Autorizare Robust

```javascript
// backend/middleware/AuthMiddleware.js
class AuthMiddleware {
  // Verifică dacă user este admin
  static requireAdmin(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (!token) {
        return res.status(401).json({ error: 'Token lipsa' });
      }
      
      const decoded = jwt.verify(token, JWT_SECRET);
      
      if (decoded.role !== 'admin') {
        return res.status(403).json({ 
          error: 'Acces interzis. Doar administratorii.' 
        });
      }
      
      req.user = decoded;
      next();
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
  
  // Verifică dacă user este client
  static requireClient(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (!token) {
        return res.status(401).json({ error: 'Token lipsa' });
      }
      
      const decoded = jwt.verify(token, JWT_SECRET);
      
      if (decoded.role !== 'client') {
        return res.status(403).json({ 
          error: 'Acces interzis. Doar clienții.' 
        });
      }
      
      req.user = decoded;
      next();
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
  
  // Verifică dacă user poate accesa propriile date
  static requireOwnershipOrAdmin(req, res, next) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      const decoded = jwt.verify(token, JWT_SECRET);
      const requestedUserId = req.params.userId;
      
      // Admin poate accesa orice
      if (decoded.role === 'admin') {
        req.user = decoded;
        return next();
      }
      
      // Client poate accesa doar propriile date
      if (decoded.role === 'client' && decoded.id === requestedUserId) {
        req.user = decoded;
        return next();
      }
      
      return res.status(403).json({ 
        error: 'Nu poți accesa datele altui utilizator' 
      });
      
    } catch (error) {
      return res.status(401).json({ error: 'Token invalid' });
    }
  }
}

module.exports = AuthMiddleware;
```

## 📊 LOGGING ȘI MONITORING OBLIGATORIU

```javascript
// backend/utils/security-logger.js
class SecurityLogger {
  static logAuthAttempt(email, success, ip, userAgent) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'AUTH_ATTEMPT',
      email,
      success,
      ip,
      userAgent,
      risk_level: success ? 'LOW' : 'MEDIUM'
    };
    
    console.log('SECURITY_LOG:', JSON.stringify(logEntry));
    
    // Store în fișier pentru audit
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
  }
  
  static logRoleAccess(userId, role, endpoint, success, ip) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'ROLE_ACCESS',
      userId,
      role,
      endpoint,
      success,
      ip,
      risk_level: success ? 'LOW' : 'HIGH'
    };
    
    console.log('SECURITY_LOG:', JSON.stringify(logEntry));
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
  }
  
  static logSuspiciousActivity(userId, activity, details) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: 'SUSPICIOUS_ACTIVITY',
      userId,
      activity,
      details,
      risk_level: 'HIGH'
    };
    
    console.log('SECURITY_ALERT:', JSON.stringify(logEntry));
    fs.appendFileSync('./logs/security.log', JSON.stringify(logEntry) + '\n');
    
    // Trimite alertă către admin
    this.alertAdmin(logEntry);
  }
}
```

## 🔍 STANDARDELE DE COD ACTUALIZATE

### 1. Frontend (React + TypeScript)
- **Componente funcționale** cu React Hooks obligatoriu
- **TypeScript strict mode** pentru toate fișierele noi  
- **CSS Modules** pentru stilizare cu clase BEM
- **Context API** pentru state management complex
- **Error Boundaries** pentru fiecare rută principală
- **Role-based rendering** în toate componentele

### 2. Backend (Node.js + Express)
- **HTTPS obligatoriu** în producție
- **Rate limiting** pe toate endpoint-urile de auth
- **Validare input** cu Joi sau Yup
- **Sanitizare output** pentru prevenir XSS  
- **JWT tokens** cu expirare configurabilă
- **CORS** configurat restrictiv

### 3. Security Headers Obligatorii
```javascript
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000');
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  next();
});
```

### 4. Validare și Sanitizare
```javascript
const { body, validationResult } = require('express-validator');

const validateLogin = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email invalid'),
  body('password')
    .isLength({ min: 8, max: 128 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Parolă trebuie să conțină: litere mari/mici, cifre, caractere speciale'),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        errors: errors.array().map(err => err.msg) 
      });
    }
    next();
  }
];
```

## 🎯 CĂUTARE ȘI TESTARE COMPLETĂ

### Caută pe internet OWASP testing guides și implementează:

1. **OWASP Web Security Testing Guide 4.4** - Authentication Testing
2. **OWASP Web Security Testing Guide 4.5** - Authorization Testing  
3. **OWASP Authentication Cheat Sheet** - Toate principiile
4. **OWASP Authorization Cheat Sheet** - ABAC/RBAC patterns
5. **NIST 800-63B** - Digital Identity Guidelines

### Folosește toate testele disponibile pentru:

- **Brute force protection** cu exponential backoff
- **Session fixation** prevention  
- **CSRF protection** cu tokens
- **SQL injection** prevention (chiar dacă folosești JSON)
- **XSS protection** cu Content Security Policy
- **Path traversal** protection în file operations
- **Privilege escalation** detection și prevention
- **Insecure direct object references** protection

## 🚨 ERORI COMUNE DE EVITAT

1. **NU** folosi credențiale default
2. **NU** expui informații sensibile în erori
3. **NU** permite guess-uirea ID-urilor
4. **NU** implementa autentificare doar pe frontend
5. **NU** folosi HTTP în producție
6. **NU** stoca parole în plain text
7. **NU** permite upload fișiere nevalidate
8. **NU** expui endpoints admin fără protecție

## 📝 MESAJE UTILIZATOR ÎN ROMÂNĂ

Toate mesajele către utilizatori **OBLIGATORIU ÎN ROMÂNĂ**:

```javascript
const MESSAGES = {
  AUTH: {
    LOGIN_SUCCESS: 'Autentificare reușită!',
    LOGIN_FAILED: 'Email sau parolă incorectă.',
    ACCESS_DENIED: 'Nu ai permisiunea să accesezi această resursă.',
    ROLE_ADMIN: 'Acces complet la CPanel administrativ.',
    ROLE_CLIENT: 'Acces la meniul personal de programări.',
    ACCOUNT_LOCKED: 'Cont temporar blocat din motive de securitate.',
    TOKEN_EXPIRED: 'Sesiunea a expirat. Te rugăm să te autentifici din nou.'
  },
  VALIDATION: {
    EMAIL_INVALID: 'Adresa de email nu este validă.',
    PASSWORD_WEAK: 'Parola trebuie să conțină minim 8 caractere, litere mari și mici, cifre și caractere speciale.',
    REQUIRED_FIELD: 'Câmpul este obligatoriu.',
    SMS_INVALID: 'Numărul de telefon nu este valid.'
  }
};
```

---

**Generată de Copilot** | Implementează testare comprehensivă bazată pe OWASP guidelines cu separarea completă admin/client! 🛡️